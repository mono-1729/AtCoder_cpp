{
    "Print to console": {
        "prefix": "tmp",
        "body": [
            "#include <bits/stdc++.h>",
            "#include <stdlib.h>",
            "using namespace std;",
			"#define rep(i, a, n) for(ll i = a; i < n; i++)",
			"#define rrep(i, a, n) for(ll i = a; i >= n; i--)",
			"#define ll long long",
			"#define pii pair<int, int>",
			"#define pll pair<ll, ll>",
            "//constexpr ll MOD = 1000000007;",
			"constexpr ll MOD = 998244353;",
			"constexpr int IINF = 1001001001;",
			"constexpr ll INF = 1LL<<60;",
			"template<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}",
			"template<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}",
            "template <ll MOD> class modint {",
            "    ll val;",
            "    static vector<modint<MOD>> factorial_vec;",
            "public:",
            "    ll get() const { return (ll)val; }",
            "    // コンストラクタ",
            "    modint(ll x = 0){",
            "        val = x % MOD;",
            "        if(val < 0) x += MOD;",
            "    }",
            "",
            "    // 入出力ストリーム",
            "    friend constexpr istream &operator>>(istream &is, modint<MOD> &x){",
            "        ll y; is >> y;",
            "        x = y;",
            "        return is;",
            "    }",
            "    friend constexpr ostream &operator<<(ostream &os, const modint<MOD> &x){",
            "        return os << x.val;",
            "    }",
            "",
            "    // 算術演算子",
            "    modint<MOD> operator -(){return modint<MOD>(-val);}",
            "    modint<MOD> operator +(const modint<MOD> &r) const { return modint<MOD>(*this) += r; }",
            "    modint<MOD> operator -(const modint<MOD> &r) const { return modint<MOD>(*this) -= r; }",
            "    modint<MOD> operator *(const modint<MOD> &r) const { return modint<MOD>(*this) *= r; }",
            "    modint<MOD> operator /(const modint<MOD> &r) const { return modint<MOD>(*this) /= r; }",
            "",
            "    // 代入演算子",
            "    modint<MOD> &operator +=(const modint<MOD> &r){",
            "        val += r.val;",
            "        if(val >= MOD) val -= MOD;",
            "        return *this;",
            "    }",
            "    modint<MOD> &operator -=(const modint<MOD> &r){",
            "        if(val < r.val) val += MOD;",
            "        val -= r.val;",
            "        return *this;",
            "    }",
            "    modint<MOD> &operator *=(const modint<MOD> &r){",
            "        val = val*r.val%MOD;",
            "        if(val < 0) val += MOD;",
            "        return *this;",
            "    }",
            "    modint<MOD> &operator /=(const modint<MOD> &r){",
            "        *this *= inv(r);",
            "        return *this;",
            "    }",
            "",
            "    //等価比較演算子",
            "    bool operator ==(const modint<MOD>& r){return this -> val == r.val;}",
            "    bool operator !=(const modint<MOD>& r){return this -> val != r.val;}",
            "    bool operator <(const modint<MOD>& r){return this -> val < r.val;}",
            "    bool operator <=(const modint<MOD>& r){return this -> val <= r.val;}",
            "    bool operator >(const modint<MOD>& r){return this -> val > r.val;}",
            "    bool operator >=(const modint<MOD>& r){return this -> val >= r.val;}",
            "",
            "    // 累乗",
            "    static modint<MOD> modpow(modint<MOD> num, ll exp){",
            "        if(!exp) return modint<MOD>(1); // 0乗",
            "        modint<MOD> ret(1);",
            "        modint<MOD> tmp = num;",
            "        while(exp){",
            "            if(exp&1) ret *= tmp;",
            "            tmp *= tmp;",
            "            exp >>= 1;",
            "        }",
            "        return ret;",
            "    }",
            "",
            "    // 逆元",
            "    static modint<MOD> inv(modint<MOD> num){",
            "        return modpow(num, MOD-2);",
            "    }",
            "",
            "    // 階乗",
            "    static modint<MOD> factorial(ll n){",
            "        modint<MOD> ret(1);",
            "        if(n == 0) return ret;",
            "        if((ll)factorial_vec.size() >= n) return factorial_vec[n-1];",
            "        ret = factorial(n-1)*n;",
            "        factorial_vec.push_back(ret);",
            "        return ret;",
            "    }",
            "",
            "    // コンビネーション",
            "    static modint<MOD> combination(ll n, ll r){",
            "        return factorial(n) / factorial(r) / factorial(n-r);",
            "    }",
            "",
            "};",
            "",
            "using mint = modint<MOD>;",
            "template <ll MOD> vector<modint<MOD>> modint<MOD>::factorial_vec;",
            "",
            "ll gcd(ll a, ll b){",
            "    if(a%b == 0){",
            "      return b;",
            "    }else{",
            "      return gcd(b, a%b);",
            "    }",
            "}",
            "",
            "ll lcm(ll a, ll b){",
            "    return a*b / gcd(a, b);",
            "}",
            "",
            "ll powMod(ll x, ll n) {",
            "    if (n == 0) return 1 % MOD;",
            "    ll val = powMod(x, n / 2);",
            "    val *= val;",
            "    val %= MOD;",
            "    if (n % 2 == 1) val *= x;",
            "    return val % MOD;",
            "}",
            "",
            "int main() {",
            "    return 0;",
            "}"
            ],
        "description": "template"
    },
    "binary_search": {
        "prefix": "bstmp",
        "body": [
            "ll ng=-1,ok=1000000000000000000;",
            "while (abs(ok - ng) > 1){",
            "    ll mid = (ok + ng) / 2 ;",
            "    bool flg=false;",
            "",
            "    if (flg) ok = mid;",
            "    else ng = mid;",
            "}",
            ],
        "description": "binary_search"
    },
    "Bellmanford": {
        "prefix": "bellmantmp",
        "body": [
            "// https://zenn.dev/reputeless/books/standard-cpp-for-competitive-programming/viewer/bellman-ford",
            "// 辺",
            "struct Edge",
            "{",
            "    ll from;",
            "    ll to;",
            "    ll cost;",
            "};",
            "",
            "// ベルマンフォード法 (基本実装)",
            "// 負閉路が存在する場合 true を返す",
            "// distances は頂点数と同じサイズ, 全要素 INF で初期化しておく",
            "bool BellmanFord(vector<Edge> &edges, vector<ll> &dist, ll start){",
            "    fill(dist.begin(), dist.end(), INF);",
            "    dist[start] = 0;",
            "    // 負の閉路がなければ、(頂点数-1)回の更新で最短路が決まる",
            "    rep(i, 0, (ll)dist.size()){",
            "        bool changed = false;",
            "        // 各辺について",
            "        for (const auto& edge : edges){",
            "            // to までの新しい距離",
            "            const ll d = (dist[edge.from] + edge.cost);",
            "            // d が現在の記録より小さければ更新",
            "            if (d < dist[edge.to]&& dist[edge.from] != INF){",
            "                dist[edge.to] = d;",
            "                changed = true;",
            "            }",
            "        }",
            "        // どの頂点も更新されなかったら終了",
            "        if (!changed){",
            "            return false;",
            "        }",
            "    }",
            "    // 負閉路の影響のある範囲を計算",
            "    // rep(i, 0, (ll)dist.size()){",
            "    // 	// 各辺について",
            "    // 	for (const auto& edge : edges){",
            "    // 		// to までの新しい距離",
            "    // 		const ll d = (dist[edge.from] + edge.cost);",
            "    // 		// d が現在の記録より小さければ更新",
            "    // 		if (d < dist[edge.to]&& dist[edge.from] != INF){",
            "    // 			dist[edge.to] = -INF;",
            "    // 		}",
            "    // 	}",
            "    // }",
            "    // 頂点回数分だけループしても更新が続くのは, 負閉路が存在するから",
            "    return true;",
            "}",
            ],
        "description": "Bellmanford"
    },
    "DFS": {
        "prefix": "dfstmp",
        "body": [
            "vector<vector<ll>> g(105);",
            "vector<ll> d(105), f(105);",
            "",
            "ll cnt = 1;",
            "void dfs(ll pos){",
            "    d[pos] = cnt;",
            "    cnt++;",
            "    for(auto npos: g[pos]){",
            "        if(d[npos] == 0) dfs(npos);",
            "    }",
            "    f[pos] = cnt;",
            "    cnt++;",
            "}",
            ],
        "description": "DFS"
    },
    "Dijkstra": {
        "prefix": "dijkstratmp",
        "body": [
            "// sを始点とする各頂点への距離の最小値を格納した配列を返す",
            "vector<ll> dijk(ll s,vector<vector<pll>> &g){",
            "    priority_queue<pll, vector<pll>, greater<pll>> que;",
            "    vector<ll> dist(100005, (1LL<<60));",
            "    que.push(make_pair(0, s));",
            "    dist[s] = 0;",
            "    while(!que.empty()){",
            "        pll q = que.top(); que.pop();",
            "        ll d = q.first, u = q.second;",
            "        if(dist[u] < d) continue;",
            "        for(auto nq: g[u]){",
            "            ll v = nq.first, cost = nq.second;",
            "            if(dist[v] > d+cost){",
            "                dist[v] = d+cost;",
            "                que.push({dist[v], v});",
            "            }",
            "        }",
            "    }",
            "    return dist;",
            "}",
            ],
        "description": "Dijkstra"
    },
    "Combination": {
        "prefix": "combtmp",
        "body": [
            "ll maxnum=200005;",
            "vector<ll> fac(maxnum), inv(maxnum), finv(maxnum);",
            "void init_fac(){",
            "    fac[0] = fac[1] = 1;",
            "    inv[1] = 1;",
            "    finv[0] = finv[1] = 1;",
            "    rep(i, 2, maxnum){",
            "        fac[i] = fac[i-1]*i%MOD;",
            "        inv[i] = MOD-MOD/i*inv[MOD%i]%MOD;",
            "        finv[i] = finv[i-1]*inv[i]%MOD;",
            "    }",
            "}",
            "ll nCr(ll n, ll r){",
            "    if(n < 0 or n-r < 0 or r < 0) return 0;",
            "    return fac[n]*(finv[n-r]*finv[r]%MOD)%MOD;",
            "}",
            "ll nHr(ll n, ll r){",
            "    return nCr(n+r-1, r);",
            "}",
            ],
        "description": "Combination"
    },
    "Eratosthenes": {
        "prefix": "erattmp",
        "body": [
            "// 0ならば素数, 0でないなら最⼩の素因数",
            "// 素因数分解や素因数の数も求めることが可能",
            "ll max_num=1000005;",
            "vector<ll> erat(max_num);",
            "void init_e(){",
            "    rep(i, 2, sqrt(max_num-1)){",
            "        if(erat[i] == 0){",
            "            for(ll j = i*i; j <= max_num-1; j += i){",
            "                if(erat[j] == 0) erat[j] = i;",
            "            }",
            "        }",
            "    }",
            "}",
            ],
        "description": "Eratosthenes"
    },
    "chineseRem": {
        "prefix": "chiinatmp",
        "body": [
            "/*",
            "中国剰余定理 :",
            "    m1とm2を互いに素な正の整数とする。",
            "        x ≡ b1 (mod. m1)",
            "        x ≡ b2 (mod. m2)",
            "    を満たす整数 x が 0 以上 m1, m2 未満にただ1つ存在する。",
            "",
            "    特にそれをｒとすると",
            "        x ≡ b1 (mod. m1), x ≡ b2 (mod. m2)",
            "        ↔ x ≡ r (mod. m1m2)",
            "    が成立する。",
            "",
            "アルゴリズム : ",
            "二元の場合 : ",
            "    x ≡ b1 (mod. m1), x ≡ b2 (mod. m2) の場合を解く。",
            "    d = gcd(m1, m2) として、拡張ユークリッドの互除法によって",
            "    m1*p+m2*q = d を満たす (p, q) を求め、",
            "    x = b1+m1((b2-b1)/d)*p とすればよい。",
            "    ( ",
            "        b1 = b2 (mod. gcd(m1, m2)) より、b2-b1はdで割り切れる。",
            "        s = ((b2-b1)/d) とおくと、m1*p+m2*q = d より、 ",
            "        s*m1*p+s*m2*q = b2-b1 ",
            "        →　s*m1*p+b1 = -s*m2*q+b2     ",
            "        x=b1+s*m1*p(=b2−s*m2*q) とおくと、",
            "        x ≡ b1 (mod. m1), x ≡ b2 (mod. m2) が成り立っていることが分かる。",
            "    )",
            "*/",
            "",
            "// 2元の場合",
            "// 負の数にも対応した mod ",
            "inline ll mod(ll a, ll m) {",
            "    return (a % m + m) % m;",
            "}",
            "",
            "inline long long mul(long long a, long long b, long long m) {",
            "    a = mod(a, m); b = mod(b, m);",
            "    if (b == 0) return 0;",
            "    long long res = mul(mod(a + a, m), b>>1, m);",
            "    if (b & 1) res = mod(res + a, m);",
            "    return res;",
            "}",
            "",
            "// 拡張ユークリッドの互除法",
            "// ap+bq=gcd(a, b) となる (p, q) を求め、d = gcd(a, b) をリターンします。",
            "ll extGCD(ll a, ll b, ll &p, ll &q){",
            "    if (b == 0) {",
            "        p = 1;",
            "        q = 0;",
            "        return a;",
            "    }",
            "    ll d = extGCD(b, a%b, q, p);",
            "    q -= a/b*p;",
            "    return d;",
            "}",
            "",
            "// 中国剰余定理",
            "// リターン値を (r, m) とすると解は x = r (mod. m)",
            "// 解なしの場合は (0, -1) をリターン",
            "pll chineseRem(const vector<ll> &b, const vector<ll> &m){",
            "    ll r = 0, M = 1;",
            "    rep(i, 0, (ll)b.size()){",
            "        ll p, q;",
            "        ll d = extGCD(M, m[i], p, q); // p is inv of m1/d (mod. m[i]/d)",
            "        if((b[i] - r) % d != 0) return {0, -1};",
            "        ll tmp = mul(((b[i] - r) / d), p, (m[i] / d));",
            "        r += M * tmp;",
            "        M *= m[i] / d;",
            "    }",
            "    return {mod(r, M), M};",
            "}",
            "//pll res = chineseRem({2, 3}, {3, 5});",
            "//cout << res.first  << res.second << endl;",
            ],
        "description": "chineseRem"
    },
    "Unionfind": {
        "prefix": "uftmp",
        "body": [
            "class UnionFind {",
            "    vector<ll> parent, maxi, mini;",
            "    inline ll root(ll n){",
            "        return (parent[n] < 0? n:parent[n] = root(parent[n]));",
            "    }",
            "public:",
            "    UnionFind(ll n_ = 1): parent(n_, -1), maxi(n_), mini(n_){",
            "        iota(maxi.begin(), maxi.end(), 0);",
            "        iota(mini.begin(), mini.end(), 0);",
            "    }",
            "",
            "    inline bool same(ll x, ll y){",
            "        return root(x) == root(y);",
            "    }",
            "",
            "    inline void unite(ll x, ll y){",
            "        ll rx = root(x);",
            "        ll ry = root(y);",
            "        if(rx == ry) return;",
            "        if(parent[rx] > parent[ry]) swap(rx, ry);",
            "        parent[rx] += parent[ry];",
            "        parent[ry] = rx;",
            "        maxi[x] = std::max(maxi[x],maxi[y]);",
            "        mini[x] = std::min(mini[x],mini[y]);",
            "    }",
            "",
            "    inline ll min(ll x){",
            "        return mini[root(x)];",
            "    }",
            "",
            "    inline ll max(ll x){",
            "        return mini[root(x)];",
            "    }",
            "",
            "    inline ll size(ll x){",
            "        return (-parent[root(x)]);",
            "    }",
            "",
            "    inline ll operator[](ll x){",
            "        return root(x);",
            "    }",
            "",
            "    inline void print(){",
            "        rep(i, 0, (ll)parent.size()) cout << root(i) << \" \";",
            "        cout << endl;",
            "    }",
            "",
            "    void clear(){",
            "        rep(i, 0, (ll)parent.size()){",
            "            parent[i] = -1;",
            "        }",
            "        iota(maxi.begin(), maxi.end(), 0);",
            "        iota(mini.begin(), mini.end(), 0);",
            "    }",
            "};",
            ],
        "description": "Unionfind"
    },
    "segtree": {
        "prefix": "segtmp",
        "body": [
            "template <typename X>",
            "struct SegTree {",
            "    using FX = function<X(X, X)>; // X•X -> X となる関数の型",
            "    ll n;",
            "    FX fx;",
            "    const X ex;",
            "    vector<X> dat;",
            "    SegTree(ll n_, FX fx_, X ex_) : n(), fx(fx_), ex(ex_), dat(n_ * 4, ex_) {",
            "        ll x = 1;",
            "        while (n_ > x) {",
            "            x *= 2;",
            "        }",
            "        n = x;",
            "    }",
            "    void set(ll i, X x) { dat[i + n - 1] = x; }",
            "    void build() {",
            "        for (ll k = n - 2; k >= 0; k--) dat[k] = fx(dat[2 * k + 1], dat[2 * k + 2]);",
            "    }",
            "    void update(ll i, X x) {",
            "        i += n - 1;",
            "        dat[i] = x;",
            "        while (i > 0) {",
            "            i = (i - 1) / 2;  // parent",
            "            dat[i] = fx(dat[i * 2 + 1], dat[i * 2 + 2]);",
            "        }",
            "    }",
            "    X query(ll a, ll b) { return query_sub(a, b, 0, 0, n); }",
            "    X query_sub(ll a, ll b, ll k, ll l, ll r) {",
            "        if (r <= a || b <= l) {",
            "            return ex;",
            "        } else if (a <= l && r <= b) {",
            "            return dat[k];",
            "        } else {",
            "            X vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);",
            "            X vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);",
            "            return fx(vl, vr);",
            "        }",
            "    }",
            "};",
            "using S = ll;",
            "",
            "auto fx = [](S x1, S x2) -> S{ return max(x1, x2); };",
            "S ex = 0;",
            ],
        "description": "segtree"
    },
    "lazy_segtree": {
        "prefix": "lazysegtmp",
        "body": [
            "template <class T, T (*op)(T, T), T (*e)(), class F, T (*mapping)(F, T), F (*composition)(F, F), F (*id)()> ",
            "class LazySegmentTree {",
            "    ll _n, size, log;",
            "    vector<T> d;",
            "    vector<F> lz;",
            "",
            "    void update(ll k) { d[k] = op(d[2 * k], d[2 * k + 1]); }",
            "",
            "    void all_apply(ll k, F f){",
            "        d[k] = mapping(f, d[k]);",
            "        if (k < size) lz[k] = composition(f, lz[k]);",
            "    }",
            "",
            "    void push(ll k){",
            "        all_apply(2*k, lz[k]);",
            "        all_apply(2*k+1, lz[k]);",
            "        lz[k] = id();",
            "    }",
            "",
            "public:",
            "    LazySegmentTree() : LazySegmentTree(0) {}",
            "    explicit LazySegmentTree(ll n) : LazySegmentTree(vector<T>(n, e())) {} // explicit で明示的に型を指定する",
            "    explicit LazySegmentTree(const vector<T> &v) : _n(int(v.size())) {",
            "        // sizeは_nを超える最小の2のべき乗",
            "        size = 1;",
            "        while(size < _n) size *= 2, log++; ",
            "",
            "        // log は木の高さ（sizeの桁数）",
            "        log = 0;",
            "        while (!(size & (1 << log))) log++;",
            "",
            "        d = vector<T>(2*size, e());",
            "        lz = vector<F>(size, id());",
            "",
            "        for(ll i = 0; i < _n; i++) d[size+i] = v[i];",
            "        for(ll i = size-1; i >= 1; i--){",
            "            update(i);",
            "        }",
            "    }",
            "",
            "    void set(ll p, T x){",
            "        assert(0 <= p && p < _n);",
            "        p += size;",
            "        for(ll i = log; i >= 1; i--) push(p >> i);",
            "        d[p] = x;",
            "        for(ll i = 1; i <= log; i++) update(p >> i);",
            "    }",
            "",
            "    T get(ll p) {",
            "        assert(0 <= p && p < _n);",
            "        p += size;",
            "        for(ll i = log; i >= 1; i--) push(p >> i);",
            "        return d[p];",
            "    }",
            "",
            "",
            "    T prod(ll l, ll r) {",
            "        assert(0 <= l && l <= r && r <= _n);",
            "        if(l == r) return e();",
            "",
            "        l += size;",
            "        r += size;",
            "",
            "        for(ll i = log; i >= 1; i--){",
            "            if(((l >> i) << i) != l) push(l >> i);",
            "            if(((r >> i) << i) != r) push((r-1) >> i);",
            "        }",
            "        ",
            "        T sml = e(), smr = e();",
            "        while(l < r){",
            "            if(l&1) sml = op(sml, d[l++]);",
            "            if(r&1) smr = op(d[--r], smr);",
            "            l >>= 1;",
            "            r >>= 1;",
            "        }",
            "",
            "        return op(sml, smr);",
            "    }",
            "",
            "    T all_prod() {return d[1]; }",
            "",
            "    void apply(ll p, F f){",
            "        assert(0 <= p && p < _n);",
            "        p += size;",
            "        for(ll i = log; i >= 1; i--) push(p >> i); ",
            "        d[p] = mapping(f, d[p]);",
            "        for(ll i = 1; i <= log; i++) update(p >> i);",
            "    }",
            "",
            "    void apply(ll l, ll r, F f){",
            "        assert(0 <= l && l <= r && r <= _n);",
            "        if(l == r) return;",
            "",
            "        l += size;",
            "        r += size;",
            "",
            "        for(ll i = log; i >= 1; i--){",
            "            if(((l >> i) << i) != l) push(l >> i);",
            "            if(((r >> i) << i) != r) push((r-1) >> i);",
            "        }",
            "",
            "        {",
            "            ll l2 = l, r2 = r;",
            "            while(l < r){",
            "                if(l&1) all_apply(l++, f);",
            "                if(r&1) all_apply(--r, f);",
            "                l >>= 1;",
            "                r >>= 1;",
            "            }",
            "            l = l2;",
            "            r = r2;",
            "        }",
            "",
            "        for(ll i = 1; i <= log; i++){",
            "            if(((l >> i) << i) != l) update(l >> i);",
            "            if(((r >> i) << i) != r) update((r-1) >> i);",
            "        }",
            "    }",
            "",
            "    // f(op(a[l], a[l + 1], ..., a[r - 1])) = trueとなる最大のｒ",
            "    template <bool (*g)(T)> ll max_right(ll l) {",
            "        return max_right(l, [](T x) { return g(x); });",
            "    }",
            "    template <class G> ll max_right(ll l, G g) {",
            "        assert(0 <= l && l <= _n);",
            "        assert(g(e()));",
            "        if (l == _n) return _n;",
            "        l += size;",
            "        for (ll i = log; i >= 1; i--) push(l >> i);",
            "        T sm = e();",
            "        do {",
            "            while (l % 2 == 0) l >>= 1;",
            "            if (!g(op(sm, d[l]))) {",
            "                while (l < size) {",
            "                    push(l);",
            "                    l = (2 * l);",
            "                    if (g(op(sm, d[l]))) {",
            "                        sm = op(sm, d[l]);",
            "                        l++;",
            "                    }",
            "                }",
            "                return l - size;",
            "            }",
            "            sm = op(sm, d[l]);",
            "            l++;",
            "        } while ((l & -l) != l);",
            "        return _n;",
            "    }",
            "",
            "    template <bool (*g)(T)> ll min_left(ll r) {",
            "        return min_left(r, [](T x) { return g(x); });",
            "    }",
            "    template <class G> ll min_left(ll r, G g) {",
            "        assert(0 <= r && r <= _n);",
            "        assert(g(e()));",
            "        if (r == 0) return 0;",
            "        r += size;",
            "        for (ll i = log; i >= 1; i--) push((r - 1) >> i);",
            "        T sm = e();",
            "        do {",
            "            r--;",
            "            while (r > 1 && (r % 2)) r >>= 1;",
            "            if (!g(op(d[r], sm))) {",
            "                while (r < size) {",
            "                    push(r);",
            "                    r = (2 * r + 1);",
            "                    if (g(op(d[r], sm))) {",
            "                        sm = op(d[r], sm);",
            "                        r--;",
            "                    }",
            "                }",
            "                return r + 1 - size;",
            "            }",
            "            sm = op(d[r], sm);",
            "        } while ((r & -r) != r);",
            "        return 0;",
            "    }",
            "};",
            ],
        "description": "lazy_segtree"
    },
    "monoid": {
        "prefix": "monoidtmp",
        "body": [
            "// 遅延セグメント木の準備",
            "using S =  ll;",
            "S op(S a, S b) { return min(a, b); }",
            "S e() { return 9e18; }",
            "// 一次関数 a x + b によって恒等写像と代入を表現",
            "using F = ll;",
            "S mapping(F a, S x) { return min(a, x); }",
            "F composition(F a, F b) { return min(a, b); }",
            "F id() { return 9e18; }",
            "// ll n;",
            "// vector<S> v(n);",
            "// LazySegmentTree<S, op, e, F, mapping, composition, id> lst(initial);",
            ],
        "description": "monoid"
    },
    "monoid_add_min": {
        "prefix": "addmintmp",
        "body": [
            "// 区間加算・区間最小値取得",
            "using S = long long;",
            "using F = long long;",
            "",
            "const S INF = 8e18;",
            "",
            "S op(S a, S b){ return std::min(a, b); }",
            "S e(){ return INF; }",
            "S mapping(F f, S x){ return f+x; }",
            "F composition(F f, F g){ return f+g; }",
            "F id(){ return 0; }",
            "// ll n;",
            "// vector<S> v(n);",
            "// LazySegmentTree<S, op, e, F, mapping, composition, id> seg(v);",
            ],
        "description": "monoid_add_min"
    },
    "monoid_add_max": {
        "prefix": "addmaxtmp",
        "body": [
            "//区間加算・区間最大値取得",
            "using S = long long;",
            "using F = long long;",
            "",
            "S op(S a, S b){ return std::max(a, b); }",
            "S e(){ return -INF; }",
            "S mapping(F f, S x){ return f+x; }",
            "F composition(F f, F g){ return f+g; }",
            "F id(){ return 0; }",
            "// ll n;",
            "// vector<S> v(n);",
            "// LazySegmentTree<S, op, e, F, mapping, composition, id> seg(v);",
            ],
        "description": "monoid_add_max"
    },
    "monoid_add_sum": {
        "prefix": "addsumtmp",
        "body": [
            "//区間加算・区間和取得",
            "struct S{",
            "    long long value;",
            "    ll size;",
            "};",
            "using F = long long;",
            "",
            "S op(S a, S b){ return {a.value+b.value, a.size+b.size}; }",
            "S e(){ return {0, 0}; }",
            "S mapping(F f, S x){ return {x.value + f*x.size, x.size}; }",
            "F composition(F f, F g){ return f+g; }",
            "F id(){ return 0; }",
            "// ll n;",
            "// vector<S> v(n, {0, 1});",
            "// LazySegmentTree<S, op, e, F, mapping, composition, id> seg(v);",
            ],
        "description": "monoid_add_sum"
    },
    "monoid_update_min": {
        "prefix": "updatemintmp",
        "body": [
            "//区間変更・区間最小値取得",
            "using S = long long;",
            "using F = long long;",
            "const S INF = 8e18;",
            "const F ID = 8e18;",
            "",
            "S op(S a, S b){ return std::min(a, b); }",
            "S e(){ return INF; }",
            "S mapping(F f, S x){ return (f == ID ? x : f); }",
            "F composition(F f, F g){ return (f == ID ? g : f); }",
            "F id(){ return ID; }",
            "// ll n;",
            "// vector<S> v(n);",
            "// LazySegmentTree<S, op, e, F, mapping, composition, id> seg(v);",
            ],
        "description": "monoid_update_min"
    },
    "monoid_update_max": {
        "prefix": "updatemaxtmp",
        "body": [
            "//区間変更・区間最大値取得",
            "using S = long long;",
            "using F = long long;",
            "const S INF = 8e18;",
            "const F ID = 8e18;",
            "",
            "S op(S a, S b){ return std::max(a, b); }",
            "S e(){ return -INF; }",
            "S mapping(F f, S x){ return (f == ID ? x : f); }",
            "F composition(F f, F g){ return (f == ID ? g : f); }",
            "F id(){ return ID; }",
            "// ll n;",
            "// vector<S> v(n);",
            "// LazySegmentTree<S, op, e, F, mapping, composition, id> seg(v);",
            ],
        "description": "monoid_update_max"
    },
    "monoid_update_sum": {
        "prefix": "updatesumtmp",
        "body": [
            "//区間変更・区間和取得",
            "struct S{",
            "    long long value;",
            "    ll size;",
            "};",
            "using F = long long;",
            "const F ID = 8e18;",
            "",
            "S op(S a, S b){ return {a.value+b.value, a.size+b.size}; }",
            "S e(){ return {0, 0}; }",
            "S mapping(F f, S x){",
            "    if(f != ID) x.value = f*x.size;",
            "    return x;",
            "}",
            "F composition(F f, F g){ return (f == ID ? g : f); }",
            "F id(){ return ID; }",
            "// ll n;",
            "// vector<S> v(n, {0, 1});",
            "// LazySegmentTree<S, op, e, F, mapping, composition, id> seg(v);",
            ],
        "description": "monoid_update_sum"
    },
    "Trie": {
        "prefix": "trietmp",
        "body": [
            "/* Trie 木： 文字の種類(char_size)、int型で0に対応する文字(base)",
            "    insert(word): 単語 word を Trie 木に挿入する",
            "    search(word): 単語 word が Trie 木にあるか判定する",
            "    start_with(prefix):  prefix が一致する単語が Trie 木にあるか判定する",
            "    count(): 挿入した単語の数を返す",
            "    size(): Trie 木の頂点数を返す",
            "    計算量：insert, search ともに O(M)（Mは単語の長さ）",
            "*/",
            "template <int char_size, int base>",
            "struct Trie {",
            "    struct Node {            // 頂点を表す構造体",
            "        vector<int> next;    // 子の頂点番号を格納。存在しなければ-1",
            "        vector<int> accept;  // 末端がこの頂点になる単語の word_id を保存",
            "        int c;               // base からの間隔をint型で表現したもの",
            "        int common;          // いくつの単語がこの頂点を共有しているか",
            "        Node(int c_) : c(c_), common(0) {",
            "            next.assign(char_size, -1);",
            "        }",
            "    };",
            "    vector<Node> nodes;  // trie 木本体",
            "    int root;",
            "    Trie() : root(0) {",
            "        nodes.push_back(Node(root));",
            "    }",
            "    // 単語の挿入",
            "    void insert(const string &word, int word_id) {",
            "        int node_id = 0;",
            "        for (int i = 0; i < (int)word.size(); i++) {",
            "            int c = (int)(word[i] - base);",
            "            int &next_id = nodes[node_id].next[c];",
            "            if (next_id == -1) {  // 次の頂点が存在しなければ追加",
            "                next_id = (int)nodes.size();",
            "                nodes.push_back(Node(c));",
            "            }",
            "            ++nodes[node_id].common;",
            "            node_id = next_id;",
            "        }",
            "        ++nodes[node_id].common;",
            "        nodes[node_id].accept.push_back(word_id);",
            "    }",
            "    void insert(const string &word) {",
            "        insert(word, nodes[0].common);",
            "    }",
            "    // 単語とprefixの検索",
            "    bool search(const string &word, bool prefix = false) {",
            "        int node_id = 0;",
            "        for (int i = 0; i < (int)word.size(); i++) {",
            "            int c = (int)(word[i] - base);",
            "            int &next_id = nodes[node_id].next[c];",
            "            if (next_id == -1) {  // 次の頂点が存在しなければ終了",
            "                return false;",
            "            }",
            "            node_id = next_id;",
            "        }",
            "        return (prefix) ? true : nodes[node_id].accept.size() > 0;",
            "    }",
            "    // prefix を持つ単語が存在するかの検索",
            "    bool start_with(const string &prefix) {",
            "        return search(prefix, true);",
            "    }",
            "    // 挿入した単語の数",
            "    int count() const {",
            "        return (nodes[0].common);",
            "    }",
            "    // Trie木のノード数",
            "    int size() const {",
            "        return ((int)nodes.size());",
            "    }",
            "};",
            ],
        "description": "trie"
    },
    "Warshall-Floyd": {
        "prefix": "wftmp",
        "body": [
            "vector<vector<ll>> d(n,vector<ll>(n,INF));",
            "rep(i,0,m){",
            "    ll a,b,c;cin>>a>>b>>c;",
            "    chmin(d[a][b],c);",
            "    chmin(d[b][a],c);",
            "}",
            "rep(k,0,n)rep(i,0,n)rep(j,0,n){",
            "    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);",
            "}",
            ],
        "description": "Warshall-Floyd"
    },
}
